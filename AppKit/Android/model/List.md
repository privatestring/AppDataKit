# ArrayList浅析
   `ArrayList` 是实现了`List`、`RandomAccess`的顺序表，当容量不足时会自动扩容<br>
   特点：访问元素效率较高，操作元素效率低（每次`add` `remove`都会对整个表进行操作）

### 初始化
```
// 可自定义初始化储存数据的数组长度
ArrayList(initialCapacity)
// 使用默认数组长度，默认长度为0
ArrayList()
```

### 扩容机制
1. 首次未设置数组长度时: 当执行`add*`添加数据会创建一个`10`个长度的数组
2. 再次扩容：当执行`add*`时会检查是否有足够空间，没有的话则增加当前长度的一半`n/2`
3. 减容：当执行`remove*`时，先获取数组当前位置的数据，整个数组从当前位置向前移动补位，
置空数组后面的数据。（这里有个问题：减少容量时ArrayList里的数组长度没有减少，意味着数据长度只增不减）

### 线程安全问题
1. 使用`CopyOnWriteArrayList`加锁的顺序列表
2. 使用`Collections#synchronizedList`


# LinkedList浅析
   `LinkedList`是实现了`List``Deque`的队列双向链表，每个节点包含了数据，上一节点和下一节点的信息，容量是动态非连续的<br>
   特点：插入、删除较快，不需要移动数据，只移动节点信息就可以了

### 初始化 `LinkedList()`

### 扩容机制 动态随数据长度


## 综合对比
* ArrayList的操作数据都是通过普通的数组实现，随机访问和修改元素比较快，但插入/删除等操作需要移动较多数据，比较适合在访问数据比较频繁的场景使用
* LinkedList是双向链表，在随机访问和修改都需要先去查找节点，但是在插入/删除数据时不需要移动数据，比较适合用在插入/删除频繁的场景中。
* LinkedList还实现了队列接口，通过头或尾进行顺序访问的同时可以删除节点，充分发挥了链表的优势。
